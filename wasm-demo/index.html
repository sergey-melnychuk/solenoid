<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereum Transaction Debugger</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            max-width: 1400px;
            min-width: 640px;
            margin: 0 auto;
            padding: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        h1 {
            color: #1a1a1a;
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        h2 {
            color: #1a1a1a;
            margin: 0 0 16px 0;
            font-size: 20px;
            font-weight: 600;
        }
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }
        .header-compact {
            display: flex;
            align-items: center;
            flex-wrap: nowrap;
            gap: 6px;
            margin-bottom: 8px;
            overflow-x: auto;
            padding-bottom: 2px;
        }
        .rpc-toggle {
            transition: all 0.2s ease;
            font-weight: 500;
        }
        .rpc-toggle:hover {
            background-color: #616161 !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(117, 117, 117, 0.3);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }
        input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s ease;
            background-color: #fafafa;
        }
        input:focus {
            outline: none;
            border-color: #2196F3;
            background-color: white;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.2);
        }
        button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button.secondary {
            background-color: #2196F3;
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.2);
        }
        button.secondary:hover {
            background-color: #1976D2;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
        }
        button.secondary:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            margin-top: 16px;
            padding: 16px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .status.error {
            border-left-color: #f44336;
            color: #c62828;
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
        }
        .status.loading {
            border-left-color: #2196F3;
            color: #1565c0;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        }
        .call-stack {
            margin-top: 20px;
        }
        .call-stack-item {
            margin-bottom: 3px;
            padding: 10px 12px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 6px;
            border-left: 4px solid #2196F3;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        .call-stack-item:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            transform: translateX(2px);
        }
        .call-stack-item.call {
            border-left-color: #4CAF50;
            background: linear-gradient(135deg, #f1f8f4 0%, #e8f5e9 100%);
        }
        .call-stack-item.return {
            border-left-color: #2196F3;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        }
        .call-stack-item.revert {
            border-left-color: #f44336;
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
        }
        .call-stack-item.halt {
            border-left-color: #000000;
            background: #ffffff;
        }
        .call-stack-item.transfer {
            border-left-color: #fdd835;
            background: #fffde7;
        }
        .call-stack-item .depth {
            display: inline-block;
            width: 30px;
            color: #666;
            font-weight: bold;
        }
        .call-stack-item .type {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            margin-right: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .call-stack-item .type.call {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }
        .call-stack-item .type.return {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
        }
        .call-stack-item .type.revert {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
        }
        .call-stack-item .type.halt {
            background: #000000;
            color: white;
        }
        .call-stack-item .type.transfer {
            background: #fdd835;
            color: #f57f17;
            font-weight: 700;
        }
        .call-stack-item .address {
            color: #2196F3;
            font-weight: bold;
        }
        .call-stack-item .details {
            margin-top: 8px;
            color: #666;
            font-size: 12px;
        }
        .call-stack-item .value {
            color: #4CAF50;
        }
        .call-stack-item .gas {
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-compact">
            <h1 style="margin: 0; white-space: nowrap;">Solenoid EVM</h1>
            <div style="display: flex; align-items: center; gap: 6px; flex-wrap: nowrap; flex: 1; justify-content: flex-end;">
                <label for="blockNumber" style="margin: 0; font-size: 14px; white-space: nowrap;">Block:</label>
                <input
                    type="number"
                    id="blockNumber"
                    placeholder="20000000"
                    style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                />
                <label for="txIndex" style="margin: 0; font-size: 14px; white-space: nowrap;">Tx Index:</label>
                <input
                    type="number"
                    id="txIndex"
                    placeholder="0"
                    value="0"
                    style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                />
                <button id="traceButton" type="button" style="margin: 0; padding: 8px 16px; white-space: nowrap;">Trace Transaction</button>
                <button id="randomButton" type="button" class="secondary" style="margin: 0; padding: 8px 16px; white-space: nowrap;">Select Random</button>
                <button id="rpcToggleButton" type="button" class="rpc-toggle" style="background-color: #757575; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; white-space: nowrap;">RPC URL</button>
            </div>
        </div>
        <div id="rpcUrlContainer" style="display: none; margin-top: 6px;">
            <input
                type="text"
                id="rpcUrl"
                placeholder="https://ethereum-rpc.publicnode.com"
                value="https://ethereum-rpc.publicnode.com"
                style="width: 100%; padding: 12px 16px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; box-sizing: border-box; background-color: #fafafa; transition: all 0.2s ease; font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;"
            />
        </div>

        <div id="status" class="status" style="display: none;"></div>
    </div>

    <div class="container">
        <h2>Call Stack</h2>
        <div id="txHashDisplay" style="margin-bottom: 12px; padding: 12px 16px; background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-radius: 8px; font-family: 'SF Mono', 'Monaco', 'Courier New', monospace; font-size: 13px; display: none; box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15); border: 1px solid rgba(33, 150, 243, 0.2);"></div>
        <div id="callStack" class="call-stack"></div>
    </div>

    <script type="module">
        import init, { trace_transaction, get_latest_block_info, get_block_info, get_transaction_hash } from './pkg/wasm_demo.js';

        let wasmInitialized = false;
        let callStack = [];
        let stateChanges = []; // Track all state changes with their depth and index
        let stateVisibility = {}; // Track visibility state for each call block (index -> boolean)
        let dataVisibility = {}; // Track visibility state for DATA fields (index -> boolean)
        let txHash = null; // Store transaction hash
        let txStatus = null; // Store transaction status (succeeded/reverted)
        let txGasUsed = null; // Store final gas used
        let txGasFee = null; // Store gas fee charged
        let txSender = null; // Store transaction sender address
        let txGasRet = null; // Store gas result object from WASM

        async function initWasm() {
            if (!wasmInitialized) {
                await init();
                wasmInitialized = true;
                console.log('WASM initialized successfully');
            }
        }

        function formatAddress(addr) {
            if (!addr) return 'N/A';
            let addrStr = addr.toString();
            if (!addrStr.startsWith('0x')) {
                addrStr = '0x' + addrStr;
            }
            // Ensure it's a valid address (42 chars: 0x + 40 hex)
            if (addrStr.length < 42) {
                addrStr = '0x' + addrStr.slice(2).padStart(40, '0');
            }
            const etherscanUrl = `https://etherscan.io/address/${addrStr}`;
            return `<a href="${etherscanUrl}" target="_blank" style="color: #2196F3; text-decoration: none; font-family: monospace;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${addrStr}</a>`;
        }

        function formatWord(word) {
            if (!word) return '0x0';
            let wordStr = word.toString();
            if (!wordStr.startsWith('0x')) {
                wordStr = '0x' + wordStr;
            }
            // Ensure it's a valid word (66 chars: 0x + 64 hex)
            if (wordStr.length < 66) {
                wordStr = '0x' + wordStr.slice(2).padStart(64, '0');
            }
            return wordStr;
        }

        function formatValue(value) {
            if (!value) return '0';
            const valStr = value.toString();
            if (valStr.startsWith('0x')) {
                const num = BigInt(valStr);
                if (num === 0n) return '0 ETH';
                return (Number(num) / 1e18).toFixed(6) + ' ETH';
            }
            return value;
        }

        function formatTxHash(hash) {
            if (!hash) return '';
            let hashStr = hash.toString();
            if (!hashStr.startsWith('0x')) {
                hashStr = '0x' + hashStr;
            }
            // Ensure it's a valid hash (66 chars: 0x + 64 hex)
            if (hashStr.length < 66) {
                hashStr = '0x' + hashStr.slice(2).padStart(64, '0');
            }
            const etherscanUrl = `https://etherscan.io/tx/${hashStr}`;
            return `<a href="${etherscanUrl}" target="_blank" style="color: #2196F3; text-decoration: none; font-weight: bold; font-family: monospace;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${hashStr}</a>`;
        }


        function addCallStackItem(event) {
            const eventData = event.data || event;
            const depth = event.depth || 0;
            const reverted = event.reverted || false;

            let item = {
                type: 'unknown',
                depth: depth,
                reverted: reverted,
                data: eventData,
                index: callStack.length
            };

            // Check for Call event
            if (eventData.Call) {
                const call = eventData.Call;
                item.type = 'call';
                
                // Track top-level call (depth 0 or 1) to get sender
                if (depth <= 1 && !txSender) {
                    txSender = call.from;
                }
                
                // Push the call item first
                callStack.push(item);
                
                // If there's a value transfer, add a separate transfer event right after
                if (call.value && call.value !== '0' && call.value !== '0x0') {
                    const transferItem = {
                        type: 'transfer',
                        depth: depth,
                        reverted: reverted,
                        data: {
                            from: call.from,
                            to: call.to,
                            value: call.value
                        },
                        index: callStack.length
                    };
                    callStack.push(transferItem);
                }
                
                // Render and return early since we've already pushed the item(s)
                renderCallStack();
                return;
            } 
            // Check for Return event (which can be a return or revert)
            else if (eventData.Return) {
                const returnData = eventData.Return;
                // A Return with ok=false or reverted=true is a revert
                if (returnData.ok === false || reverted) {
                    item.type = 'revert';
                } else {
                    item.type = 'return';
                }
                
                // Note: Transaction status and gas used now come from the transaction result,
                // not from Return events
            }
            // Check for Account event (to track gas fee from SetValue)
            else if (eventData.Account) {
                const accountEvent = eventData.Account;
                // Track SetValue for the sender to calculate gas fee
                if (accountEvent.SetValue && txSender && accountEvent.SetValue.address === txSender) {
                    const oldBalance = BigInt(accountEvent.SetValue.val);
                    const newBalance = BigInt(accountEvent.SetValue.new);
                    const balanceDiff = oldBalance - newBalance;
                    // Only update if this is a decrease (fee payment)
                    if (balanceDiff > 0n) {
                        txGasFee = balanceDiff.toString();
                    }
                }
                // Don't add account events as separate items
                return;
            }
            // Check for Fee event
            else if (eventData.Fee) {
                const feeEvent = eventData.Fee;
                // Track fee if available
                if (feeEvent.total) {
                    txGasFee = feeEvent.total.toString();
                }
                // Don't add fee events as separate items
                return;
            }
            // Check for Halt event
            else if (eventData.Halt) {
                const haltReason = eventData.Halt;
                item.type = 'halt';
                // Map halt reason to display string and preserve original event data
                let reasonStr;
                if (haltReason === 'OutOfGas') {
                    reasonStr = 'OOG';
                } else if (haltReason === 'InvalidOpcode') {
                    reasonStr = 'InvalidOpcode';
                } else {
                    reasonStr = haltReason;
                }
                // Preserve original event data and add reason for display
                item.data = { ...eventData, reason: reasonStr };
            }
            // Check for State event
            else if (eventData.State) {
                // Store state change with its depth and index for later association
                stateChanges.push({
                    depth: depth,
                    index: callStack.length,
                    data: eventData.State
                });
                // Don't add state events as separate items, they're shown within calls
                return;
            }

            callStack.push(item);
            renderCallStack();
        }


        window.toggleStateVisibility = function(index) {
            stateVisibility[index] = !stateVisibility[index];
            const stateDiv = document.getElementById(`state-changes-${index}`);
            const button = stateDiv?.previousElementSibling;
            if (stateDiv && button) {
                stateDiv.style.display = stateVisibility[index] ? '' : 'none';
                // Extract count from button text (format: "Show/Hide State (N)")
                const match = button.textContent.match(/\((\d+)\)/);
                const count = match ? match[1] : '0';
                button.textContent = `${stateVisibility[index] ? 'Hide' : 'Show'} State (${count})`;
            }
        };

        window.toggleDataVisibility = function(index) {
            dataVisibility[index] = !dataVisibility[index];
            const dataDiv = document.getElementById(`data-${index}`);
            const button = dataDiv?.previousElementSibling;
            if (dataDiv && button) {
                dataDiv.style.display = dataVisibility[index] ? '' : 'none';
                // Extract length from button text (format: "Show/Hide DATA (N)")
                const match = button.textContent.match(/\((\d+)\)/);
                const length = match ? match[1] : '0';
                button.textContent = dataVisibility[index] ? `Hide DATA (${length})` : `Show DATA (${length})`;
            }
        };

        function renderCallStack() {
            const container = document.getElementById('callStack');
            const txHashContainer = document.getElementById('txHashDisplay');
            
            // Show transaction hash in separate container
            console.log('renderCallStack - txHash:', txHash, 'txHashContainer:', txHashContainer);
            if (txHashContainer) {
                if (txHash) {
                    console.log('Displaying tx hash:', txHash);
                    txHashContainer.style.display = 'block';
                    const hashHtml = formatTxHash(txHash);
                    console.log('Hash HTML:', hashHtml);
                    
                    let statusHtml = `<strong>TX:</strong> ${hashHtml}`;
                    
                    // Add status and gas used if available
                    if (txStatus || txGasUsed !== null) {
                        statusHtml += '<br>';
                        if (txStatus) {
                            const statusColor = txStatus === 'succeeded' ? '#4CAF50' : '#f44336';
                            statusHtml += `<span style="margin-top: 4px; display: inline-block;"><strong>Status:</strong> <span style="color: ${statusColor}; font-weight: 600;">${txStatus === 'succeeded' ? 'Succeeded' : 'Reverted'}</span></span>`;
                        }
                        if (txGasUsed !== null) {
                            statusHtml += `<span style="margin-left: 12px; margin-top: 4px; display: inline-block;"><strong>Gas Used:</strong> <span style="font-family: monospace;">${txGasUsed.toLocaleString()}</span></span>`;
                        }
                    }
                    
                    // Add gas results if available
                    if (txGasRet) {
                        statusHtml += `<br><strong>Gas:</strong> ${txGasRet.gas_use} | ${txGasRet.gas_max}<br><strong>Fee:</strong> ${formatValue(txGasRet.gas_fee)}`;
                    }
                    
                    txHashContainer.innerHTML = statusHtml;
                } else {
                    console.log('No tx hash, hiding container');
                    txHashContainer.style.display = 'none';
                }
            } else {
                console.error('txHashContainer element not found!');
            }
            
            if (!container) return;
            container.innerHTML = '';

            callStack.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = `call-stack-item ${item.type}`;
                div.setAttribute('data-depth', item.depth);
                div.style.marginLeft = `${item.depth * 20}px`;

                let content = `<span class="type ${item.type}">${item.type === 'transfer' ? 'BALANCE' : item.type.toUpperCase()}</span>`;

                if (item.type === 'call' && item.data.Call) {
                    const call = item.data.Call;
                    content += ` <span class="address">${formatAddress(call.to)}</span>`;
                    content += `</div><div class="details" style="margin-top: 4px; margin-left: 20px; font-size: 11px; color: #666; line-height: 1.6;">`;
                    content += `<div style="margin-bottom: 2px;"><strong>FROM:</strong> ${formatAddress(call.from)}</div>`;
                    if (call.value && call.value !== '0' && call.value !== '0x0') {
                        content += `<div style="margin-bottom: 2px;"><strong>VALUE:</strong> <span class="value">${formatValue(call.value)}</span></div>`;
                    } else {
                        content += `<div style="margin-bottom: 2px;"><strong>VALUE:</strong> 0 ETH</div>`;
                    }
                    if (call.gas) {
                        const gasStr = call.gas.toString();
                        const gasNum = gasStr.startsWith('0x') ? BigInt(gasStr).toString() : gasStr;
                        content += `<div style="margin-bottom: 2px;"><strong>GAS:</strong> <span class="gas">${gasNum}</span></div>`;
                    }
                    if (call.type) {
                        const typeStr = call.type.toString();
                        const capitalizedType = typeStr.charAt(0).toUpperCase() + typeStr.slice(1).toLowerCase();
                        content += `<div style="margin-bottom: 2px;"><strong>TYPE:</strong> ${capitalizedType}</div>`;
                    }
                    if (call.data) {
                        let dataStr = call.data.toString();
                        if (!dataStr.startsWith('0x')) {
                            dataStr = '0x' + dataStr;
                        }
                        const dataLength = dataStr.length - 2; // Subtract 2 for '0x' prefix
                        const isDataVisible = dataVisibility[index] || false;
                        const dataDisplayStyle = isDataVisible ? '' : 'display: none;';
                        content += `<div style="margin-bottom: 2px;">`;
                        content += `<button class="toggle-data-btn" data-index="${index}" style="background-color: #757575; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; margin-bottom: 4px;">${isDataVisible ? 'Hide' : 'Show'} DATA (${dataLength})</button>`;
                        content += `<div id="data-${index}" style="word-break: break-all; overflow-wrap: break-word; ${dataDisplayStyle}"><strong>DATA:</strong> <span style="font-family: monospace; color: #666;">${dataStr}</span></div>`;
                        content += `</div>`;
                    }
                    content += `</div>`;
                    
                    // Find state changes that occurred between this call and its matching return
                    // Look for the matching return at the same depth
                    let matchingReturnIdx = -1;
                    for (let i = index + 1; i < callStack.length; i++) {
                        const nextItem = callStack[i];
                        if ((nextItem.type === 'return' || nextItem.type === 'revert') && 
                            nextItem.depth === item.depth) {
                            matchingReturnIdx = i;
                            break;
                        }
                        // If we hit a call at same or lower depth, we've gone too far
                        if (nextItem.type === 'call' && nextItem.depth <= item.depth) {
                            break;
                        }
                    }
                    
                    // Collect state changes between this call and its return
                    const callStateChanges = stateChanges.filter(sc => {
                        return sc.index > index && 
                               (matchingReturnIdx === -1 || sc.index < matchingReturnIdx) &&
                               sc.depth >= item.depth;
                    });
                    
                    if (callStateChanges.length > 0) {
                        const isVisible = stateVisibility[index] || false;
                        const toggleText = isVisible ? 'Hide' : 'Show';
                        const stateDisplayStyle = isVisible ? '' : 'display: none;';
                        content += `<div style="margin-top: 6px; margin-left: 20px;">`;
                        content += `<button class="toggle-state-btn" data-index="${index}" style="background-color: #757575; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; margin-bottom: 4px;">${toggleText} State (${callStateChanges.length})</button>`;
                        content += `<div id="state-changes-${index}" style="margin-top: 3px; font-size: 11px; color: #666; line-height: 1.3; word-break: break-all; overflow-wrap: break-word; ${stateDisplayStyle}">`;
                        callStateChanges.forEach(stateChange => {
                            if (stateChange.data.Put) {
                                const put = stateChange.data.Put;
                                content += `  <span style="color: #4CAF50;">PUT</span> `;
                                content += `${formatAddress(put.address)}<span style="word-break: break-all;">[</span><span style="font-family: monospace;">${formatWord(put.key)}</span>] `;
                                content += `<span style="color: #999; font-family: monospace;">${formatWord(put.val)}</span> → `;
                                content += `<span style="color: #2196F3; font-family: monospace;">${formatWord(put.new)}</span><br>`;
                            } else if (stateChange.data.Get) {
                                const get = stateChange.data.Get;
                                content += `  <span style="color: #888;">GET</span> `;
                                content += `${formatAddress(get.address)}<span style="word-break: break-all;">[</span><span style="font-family: monospace;">${formatWord(get.key)}</span>] = `;
                                content += `<span style="color: #999; font-family: monospace;">${formatWord(get.val)}</span><br>`;
                            }
                        });
                        content += `</div></div>`;
                    }
                } else if (item.type === 'return' && item.data.Return) {
                    const ret = item.data.Return;
                    content += ` <span style="color: ${ret.ok ? '#4CAF50' : '#f44336'}">${ret.ok ? 'OK' : 'FAILED'}</span>`;
                    content += `</div><div class="details" style="margin-top: 4px; margin-left: 20px; font-size: 11px; color: #666; line-height: 1.6;">`;
                    if (ret.gas_used !== undefined) {
                        content += `<div style="margin-bottom: 2px;"><strong>GAS:</strong> <span class="gas">${ret.gas_used}</span></div>`;
                    }
                    if (ret.data) {
                        let dataStr = ret.data.toString();
                        if (!dataStr.startsWith('0x')) {
                            dataStr = '0x' + dataStr;
                        }
                        const dataLength = dataStr.length - 2; // Subtract 2 for '0x' prefix
                        const isDataVisible = dataVisibility[index] || false;
                        const dataDisplayStyle = isDataVisible ? '' : 'display: none;';
                        content += `<div style="margin-bottom: 2px;">`;
                        content += `<button class="toggle-data-btn" data-index="${index}" style="background-color: #757575; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; margin-bottom: 4px;">${isDataVisible ? 'Hide' : 'Show'} DATA (${dataLength})</button>`;
                        content += `<div id="data-${index}" style="word-break: break-all; overflow-wrap: break-word; ${dataDisplayStyle}"><strong>DATA:</strong> <span style="font-family: monospace; color: #666;">${dataStr}</span></div>`;
                        content += `</div>`;
                    }
                    content += `</div>`;
                } else if (item.type === 'revert' && item.data.Return) {
                    const ret = item.data.Return;
                    content += ` <span style="color: #f44336">REVERT</span>`;
                    content += `</div><div class="details" style="margin-top: 4px; margin-left: 20px; font-size: 11px; color: #666; line-height: 1.6;">`;
                    if (ret.gas_used !== undefined) {
                        content += `<div style="margin-bottom: 2px;"><strong>GAS:</strong> <span class="gas">${ret.gas_used}</span></div>`;
                    }
                    if (ret.data) {
                        let dataStr = ret.data.toString();
                        if (!dataStr.startsWith('0x')) {
                            dataStr = '0x' + dataStr;
                        }
                        const dataLength = dataStr.length - 2; // Subtract 2 for '0x' prefix
                        const isDataVisible = dataVisibility[index] || false;
                        const dataDisplayStyle = isDataVisible ? '' : 'display: none;';
                        content += `<div style="margin-bottom: 2px;">`;
                        content += `<button class="toggle-data-btn" data-index="${index}" style="background-color: #757575; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; margin-bottom: 4px;">${isDataVisible ? 'Hide' : 'Show'} DATA (${dataLength})</button>`;
                        content += `<div id="data-${index}" style="word-break: break-all; overflow-wrap: break-word; ${dataDisplayStyle}"><strong>DATA:</strong> <span style="font-family: monospace; color: #666;">${dataStr}</span></div>`;
                        content += `</div>`;
                    }
                    if (ret.error) {
                        content += `<div style="margin-bottom: 2px;"><strong>ERROR:</strong> <span style="color: #f44336;">${ret.error}</span></div>`;
                    }
                    content += `</div>`;
                } else if (item.type === 'transfer' && item.data.from && item.data.to && item.data.value) {
                    const transfer = item.data;
                    const valueFormatted = formatValue(transfer.value);
                    content += ` <span class="address">${formatAddress(transfer.from)}</span> → <span class="address">${formatAddress(transfer.to)}</span> <span class="value" style="color: #f57f17; font-weight: 600;">${valueFormatted}</span>`;
                    content += `</div>`;
                } else if (item.type === 'halt' && item.data.reason) {
                    const reason = item.data.reason;
                    content += ` <span style="color: #333;">${reason}</span>`;
                    content += `</div>`;
                } else if (item.type === 'state' && item.data.State) {
                    const state = item.data.State;
                    if (state.Put) {
                        const put = state.Put;
                        content = `<span style="word-break: break-all; overflow-wrap: break-word;"><span style="color: #666; font-size: 11px;">  </span>`;
                        content += `<span style="color: #4CAF50;">PUT</span> `;
                        content += `<span style="word-break: break-all; overflow-wrap: break-word;">${formatAddress(put.address)}<span style="word-break: break-all;">[</span>${formatWord(put.key)}]</span> `;
                        content += `<span style="color: #999;">${formatWord(put.val)}</span> → `;
                        content += `<span style="color: #2196F3;">${formatWord(put.new)}</span></span>`;
                    } else if (state.Get) {
                        const get = state.Get;
                        content = `<span style="word-break: break-all; overflow-wrap: break-word;"><span style="color: #666; font-size: 11px;">  </span>`;
                        content += `<span style="color: #666;">GET</span> `;
                        content += `<span style="word-break: break-all; overflow-wrap: break-word;">${formatAddress(get.address)}<span style="word-break: break-all;">[</span>${formatWord(get.key)}]</span> = `;
                        content += `<span style="color: #999;">${formatWord(get.val)}</span></span>`;
                    }
                }

                div.innerHTML = content;
                container.appendChild(div);
            });

            // Attach event listeners for toggle buttons
            container.querySelectorAll('.toggle-data-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    toggleDataVisibility(index);
                });
            });

            container.querySelectorAll('.toggle-state-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    toggleStateVisibility(index);
                });
            });
        }

        window.traceTransaction = async function() {
            const rpcUrl = document.getElementById('rpcUrl').value;
            const blockNumber = document.getElementById('blockNumber').value;
            const txIndex = document.getElementById('txIndex').value;
            const statusDiv = document.getElementById('status');
            const button = document.getElementById('traceButton');

            if (!rpcUrl) {
                statusDiv.className = 'status error';
                statusDiv.textContent = 'Please enter an RPC URL';
                statusDiv.style.display = 'block';
                return;
            }

            if (!blockNumber) {
                statusDiv.className = 'status error';
                statusDiv.textContent = 'Please enter a block number';
                statusDiv.style.display = 'block';
                return;
            }

            if (txIndex === '') {
                statusDiv.className = 'status error';
                statusDiv.textContent = 'Please enter a transaction index';
                statusDiv.style.display = 'block';
                return;
            }

            try {
                button.disabled = true;
                const randomButton = document.getElementById('randomButton');
                const rpcToggleButton = document.getElementById('rpcToggleButton');
                if (randomButton) randomButton.disabled = true;
                if (rpcToggleButton) rpcToggleButton.disabled = true;
                
                statusDiv.className = 'status loading';
                statusDiv.textContent = `Tracing transaction at block ${blockNumber}, index ${txIndex}...`;
                statusDiv.style.display = 'block';

                // Reset state
                callStack = [];
                stateChanges = [];
                stateVisibility = {};
                dataVisibility = {};
                txHash = null;
                txStatus = null;
                txGasUsed = null;
                txGasFee = null;
                txSender = null;
                txGasRet = null;
                const callStackEl = document.getElementById('callStack');
                const txHashEl = document.getElementById('txHashDisplay');
                if (callStackEl) callStackEl.innerHTML = '';
                if (txHashEl) {
                    txHashEl.style.display = 'none';
                }

                await initWasm();

                // Get transaction hash first and display it immediately
                const blockNumStr = String(Math.floor(Number(blockNumber)));
                const txIdxStr = String(Math.floor(Number(txIndex)));
                
                if (isNaN(Number(blockNumber)) || isNaN(Number(txIndex))) {
                    throw new Error('Invalid block number or transaction index');
                }

                // Check if tx hash is already set correctly for this block/tx index
                let hashNeedsUpdate = true;
                if (txHash) {
                    try {
                        const expectedHash = await get_transaction_hash(rpcUrl, blockNumStr, txIdxStr);
                        if (txHash === expectedHash) {
                            hashNeedsUpdate = false;
                        }
                    } catch (e) {
                        // If we can't verify, proceed to update
                        console.warn('Could not verify existing hash, will update:', e);
                    }
                }

                if (hashNeedsUpdate) {
                    try {
                        const hash = await get_transaction_hash(rpcUrl, blockNumStr, txIdxStr);
                        txHash = hash;
                        const txHashContainer = document.getElementById('txHashDisplay');
                        if (txHashContainer && txHash) {
                            txHashContainer.style.display = 'block';
                            txHashContainer.innerHTML = `<strong>TX:</strong> ${formatTxHash(txHash)}`;
                        }
                    } catch (e) {
                        console.warn('Could not fetch transaction hash early:', e);
                    }
                } else {
                    // Hash is already correct, just ensure it's displayed
                    const txHashContainer = document.getElementById('txHashDisplay');
                    if (txHashContainer && txHash) {
                        txHashContainer.style.display = 'block';
                        txHashContainer.innerHTML = `<strong>TX:</strong> ${formatTxHash(txHash)}`;
                    }
                }

                // Create callback function that will be called from Rust
                const callback = (eventJson) => {
                    try {
                        // eventJson is a string containing JSON, parse it
                        let event;
                        if (typeof eventJson === 'string') {
                            event = JSON.parse(eventJson);
                        } else {
                            event = eventJson;
                        }
                        console.log('Received event:', event);
                        addCallStackItem(event);
                    } catch (e) {
                        console.error('Error parsing event:', e, eventJson);
                    }
                    return undefined; // Return undefined for void callback
                };

                // Call WASM function - pass as strings to avoid BigInt conversion issues
                const [resultTxHash, resultGasRet] = await trace_transaction(
                    rpcUrl,
                    blockNumStr,
                    txIdxStr,
                    callback
                );
                txGasRet = JSON.parse(resultGasRet);

                // Update transaction hash if not already set (should already be set above)
                if (!txHash && resultTxHash) {
                    txHash = resultTxHash;
                }
                
                renderCallStack(); // Re-render to show the transaction hash

                statusDiv.className = 'status';
                statusDiv.textContent = `Successfully traced transaction! Found ${callStack.length} events.`;
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = `Error: ${error}`;
                console.error('Trace error:', error);
            } finally {
                button.disabled = false;
                const randomButton = document.getElementById('randomButton');
                const rpcToggleButton = document.getElementById('rpcToggleButton');
                if (randomButton) randomButton.disabled = false;
                if (rpcToggleButton) rpcToggleButton.disabled = false;
            }
        };

        window.selectRandom = async function() {
            const rpcUrl = document.getElementById('rpcUrl').value;
            const statusDiv = document.getElementById('status');
            const randomButton = document.getElementById('randomButton');
            const blockNumberInput = document.getElementById('blockNumber');
            const txIndexInput = document.getElementById('txIndex');

            if (!rpcUrl) {
                statusDiv.className = 'status error';
                statusDiv.textContent = 'Please enter an RPC URL';
                statusDiv.style.display = 'block';
                return;
            }

            try {
                randomButton.disabled = true;
                statusDiv.className = 'status loading';
                statusDiv.textContent = 'Fetching latest blocks...';
                statusDiv.style.display = 'block';

                // Clear call stack and reset transaction hash
                callStack = [];
                stateChanges = [];
                stateVisibility = {};
                dataVisibility = {};
                txHash = null;
                txStatus = null;
                txGasUsed = null;
                txGasFee = null;
                txSender = null;
                txGasRet = null;
                const callStackContainer = document.getElementById('callStack');
                if (callStackContainer) {
                    callStackContainer.innerHTML = '';
                }
                const txHashEl = document.getElementById('txHashDisplay');
                if (txHashEl) {
                    txHashEl.style.display = 'none';
                }
                const txHashContainer = document.getElementById('txHashDisplay');
                if (txHashContainer) {
                    txHashContainer.style.display = 'none';
                    txHashContainer.innerHTML = '';
                }

                await initWasm();

                // Get latest block info
                const latestBlockInfoJson = await get_latest_block_info(rpcUrl);
                const latestBlockInfo = JSON.parse(latestBlockInfoJson);
                const latestBlockNumber = Math.floor(Number(latestBlockInfo.blockNumber));

                // Select a random block from the latest 20 blocks
                const blocksToCheck = 20;
                const startBlock = Math.max(0, latestBlockNumber - blocksToCheck + 1);
                const randomBlockOffset = Math.floor(Math.random() * Math.min(blocksToCheck, latestBlockNumber + 1));
                const selectedBlockNumber = startBlock + randomBlockOffset;

                // Fetch the selected block's info
                statusDiv.textContent = `Checking block ${selectedBlockNumber}...`;
                let selectedBlock = selectedBlockNumber;
                let txCount = 0;
                let blockFound = false;

                // Try blocks starting from the randomly selected one, going backwards
                for (let i = 0; i < blocksToCheck; i++) {
                    const blockToCheck = selectedBlockNumber - i;
                    if (blockToCheck < 0) break;
                    
                    try {
                        const blockInfoJson = await get_block_info(rpcUrl, blockToCheck.toString());
                        const blockInfo = JSON.parse(blockInfoJson);
                        txCount = Math.floor(Number(blockInfo.txCount));
                        
                        if (txCount > 0) {
                            selectedBlock = blockToCheck;
                            blockFound = true;
                            break;
                        }
                    } catch (e) {
                        // Continue to next block if this one fails
                        continue;
                    }
                }

                if (!blockFound || txCount === 0) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'No transactions found in recent blocks';
                    return;
                }

                // Select random transaction index
                const randomTxIndex = Math.floor(Math.random() * txCount);

                // Fill in the form fields
                blockNumberInput.value = selectedBlock.toString();
                txIndexInput.value = randomTxIndex.toString();

                // Get and display the transaction hash
                try {
                    const resultHash = await get_transaction_hash(rpcUrl, selectedBlock.toString(), randomTxIndex.toString());
                    txHash = resultHash;
                    if (txHashContainer && txHash) {
                        txHashContainer.style.display = 'block';
                        txHashContainer.innerHTML = `<strong>TX:</strong> ${formatTxHash(txHash)}`;
                    }
                } catch (e) {
                    console.error('Failed to get transaction hash:', e);
                }

                statusDiv.className = 'status';
                statusDiv.textContent = `Selected block ${selectedBlock}, transaction ${randomTxIndex} of ${txCount}`;
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = `Error: ${error}`;
                console.error('Select random error:', error);
            } finally {
                randomButton.disabled = false;
            }
        };


        // Handle RPC input and button
        document.addEventListener('DOMContentLoaded', function() {
            const rpcInput = document.getElementById('rpcUrl');
            const rpcToggleButton = document.getElementById('rpcToggleButton');
            const rpcContainer = document.getElementById('rpcUrlContainer');
            const traceButton = document.getElementById('traceButton');
            const randomButton = document.getElementById('randomButton');
            
            // Attach click handler to RPC toggle button
            if (rpcToggleButton) {
                rpcToggleButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('RPC toggle button clicked');
                    if (rpcContainer) {
                        const isHidden = rpcContainer.style.display === 'none' || rpcContainer.style.display === '';
                        if (isHidden) {
                            rpcContainer.style.display = 'block';
                            setTimeout(() => {
                                if (rpcInput) {
                                    rpcInput.focus();
                                    rpcInput.select();
                                }
                            }, 50);
                        } else {
                            rpcContainer.style.display = 'none';
                        }
                    }
                });
            } else {
                console.error('rpcToggleButton not found');
            }
            
            // Attach click handler to Trace Transaction button
            if (traceButton) {
                traceButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Trace button clicked');
                    if (typeof window.traceTransaction === 'function') {
                        window.traceTransaction().catch(err => {
                            console.error('Error in traceTransaction:', err);
                        });
                    } else {
                        console.error('window.traceTransaction is not a function:', typeof window.traceTransaction);
                    }
                });
            } else {
                console.error('traceButton not found');
            }
            
            // Attach click handler to Select Random button
            if (randomButton) {
                randomButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Random button clicked');
                    if (typeof window.selectRandom === 'function') {
                        window.selectRandom().catch(err => {
                            console.error('Error in selectRandom:', err);
                        });
                    } else {
                        console.error('window.selectRandom is not a function:', typeof window.selectRandom);
                    }
                });
            } else {
                console.error('randomButton not found');
            }
            
            console.log('Button handlers attached. Functions available:', {
                traceTransaction: typeof window.traceTransaction,
                selectRandom: typeof window.selectRandom
            });
            
            // Handle Enter key in RPC input
            if (rpcInput) {
                rpcInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        this.blur();
                        if (rpcContainer) {
                            rpcContainer.style.display = 'none';
                        }
                    }
                });
            }
        });

        // Initialize WASM on page load
        initWasm().catch(console.error);
    </script>
</body>
</html>

